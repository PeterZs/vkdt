#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable

#include "shared.glsl"
#include "shared/render3d.glsl"

layout(local_size_x = DT_LOCAL_SIZE_X, local_size_y = DT_LOCAL_SIZE_Y, local_size_z = 1) in;

layout(std140, set = 0, binding = 1) uniform params_t
{ 
  float alpha;
  float taa;
  float lalpha;
  int   iter;
} params;

layout(set = 1, binding = 0) uniform sampler2D img_mv;    // motion vectors
layout(set = 1, binding = 1) uniform sampler2D img_irrp;  // previous irradiance (noisy)
layout(set = 1, binding = 2) readonly buffer irrc_t { float v[]; } irrc; // current  irradiance (noisy)
layout(set = 1, binding = 3) uniform sampler2D img_gbufp; // old gbuffer
layout(set = 1, binding = 4) uniform sampler2D img_gbufc; // current gbuffer
layout(set = 1, binding = 5) uniform writeonly image2D img_out; // output a bit less noisy light

void
main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, imageSize(img_out)))) return;

  ivec2 sz = imageSize(img_out);
  ivec2 mv = ivec2(texture(img_mv, (ipos+0.5)/vec2(sz)).rg);
  const uint idx = 4*(sz.x * ipos.y + ipos.x);
  vec3 L = vec3(irrc.v[idx], irrc.v[idx+1], irrc.v[idx+2]);
  vec3 Lo = texture(img_irrp, vec2(ipos+mv+0.5)/vec2(sz)).rgb;

  vec4 gbufc = texelFetch(img_gbufc, ipos, 0);
  vec4 gbufp = texelFetch(img_gbufp, ivec2(ipos+mv), 0);

  float alpha = params.lalpha; // blend weight, larger means use more of the history.
  // predict temporal variance from biased moments.
  // could use a bias correction scheme as adam does if we knew the number of iterations.
  float sigma = 1;//luminance_rec2020(L) - irrc.v[idx+3];//sqrt(max(0, gbufc.w - gbufc.z*gbufc.z));
  // float sigmap = sqrt(max(0, gbufp.w - gbufp.z*gbufp.z));

  // discontinuity detection
  // alpha *= smoothstep(sigma, 0.0, abs(gbufc.z - length(L)));

  // gbuffer weight:
  vec3 nc = geo_decode_normal(floatBitsToUint(gbufc.y));
  vec3 np = geo_decode_normal(floatBitsToUint(gbufp.y));
  // alpha *= smoothstep(0.8, 1.0, dot(nc, np));
  alpha *= smoothstep(0.02*max(gbufc.x, gbufp.x), 0.0, abs(gbufc.x - gbufp.x));

  L = mix(L, Lo, alpha);
  // L = vec3(gbufc.z, sigmac, sigmap); // visualise mean and variance

  imageStore(img_out, ipos, vec4(L, 1));
}
