#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable
#include "shared.glsl"
#include "../rt/colour.glsl"
layout(local_size_x = DT_LOCAL_SIZE_X, local_size_y = DT_LOCAL_SIZE_Y, local_size_z = 1) in;
layout(std140, set = 0, binding = 0) uniform global_t
{
  int frame;
  int frame_cnt;
} global;
layout(std140, set = 0, binding = 1) uniform params_t
{
  int   film;
  float ev_film;
  float gamma_film;
  int   paper;
  float ev_paper;
  float gamma_paper;
  int   grain;
  float grain_size;
  float grain_uniformity;
  int   enlarger;
  float filter_c;
  float filter_m;
  float filter_y;
  float tune_m;
  float tune_y;
  float couplers;
} params;
layout(set = 1, binding = 0) uniform sampler2D img_in;
layout(set = 1, binding = 1) uniform writeonly image2D img_out;
layout(set = 1, binding = 2) uniform sampler2D img_filmsim;
layout(set = 1, binding = 3) uniform sampler2D img_coeff;   // spectral upsampling for emission
#include "shared/upsample.glsl"
#include "filmsim.glsl"

void main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, imageSize(img_out)))) return;

  vec3 rgb = texelFetch(img_in, ipos, 0).rgb;

  int film  = params.film;
  int paper = 7 + params.paper;
  float dye_density_min_factor_film  = 1.0;
  float dye_density_min_factor_paper = 0.4;
  float gamma_factor_film  = params.gamma_film;
  float gamma_factor_paper = params.gamma_paper;
  float log_exp_min = -4.0;
  float log_exp_max =  4.0;

  vec3 log_raw;
  { // film exposure in camera and chemical development
    vec4 d65cf = fetch_coeff(vec3(1));
    vec4 coeff = fetch_coeff(rgb);
    // const mat3 M = mat3(
    //      1.66022677, -0.12455334, -0.01815514,
    //     -0.58754761,  1.13292605, -0.10060303,
    //     -0.07283825, -0.00834963,  1.11899817);
    // vec3 srgb = M * rgb;
    vec2 tc = vec2(0, get_tcy(s_sensitivity, film));
    vec3 raw = vec3(0.0);
    for(int l=0;l<=40;l++)
    {
      float pdf = 40.0;
      float lambda = 380 + l*10;
      tc.x = (l+0.5)/256.0;
      float val = sigmoid_eval(coeff, lambda);
      // this upsamples *reflectances*, i.e. 111 is equal energy not D65
      // float val = colour_upsample(srgb, vec4(lambda)).x * sigmoid_eval(d65cf, lambda);
      // not sure if needed: cuts off wavelength ranges that the spectral
      // upsampling doesn't care about since it is outside the XYZ support
      float env = envelope(lambda);
      vec3 log_sensitivity = texture(img_filmsim, tc).rgb;
      // vec3 log_sensitivity = sample_catmull_rom_1d(img_filmsim, tc).rgb;
      vec3 sensitivity = pow(vec3(10.0), log_sensitivity);
      sensitivity = mix(sensitivity, vec3(0.0), isnan(sensitivity));
      raw += sensitivity * val * env / pdf;
    }
    // TODO: the following two require to split the kernel and blur the intermediates:
      // TODO gaussian blur / lens radius
      // TODO apply halation
    log_raw = params.ev_film * (log(2.0)/log(10.0)) + log(raw+1e-10) * (1.0/log(10.0));
    // rgb = 100.0*abs(coeff.xxx);//pow(vec3(10.0), log_raw);
    // imageStore(img_out, ipos, vec4(rgb, 1));
    // return;
    // rgb = texture(img_filmsim, vec2(0.5, get_tcy(0,0))).rgb;
  }

  vec3 density_cmy;
  { // develop film
    if(params.couplers > 0.0)
    { // now the couplers. try the following:
      // we have aggregate/measured density curves D(e) where e is the undiffused pixel input
      // and we want reduced ones D_0(e_0) where e_0 will be diffused + inhibited e_0 = e - K*e
      // because we observe D(e) = D_0(e - K*e) on a test strip where the spatial kernel does
      // mainly nothing,  D(e) = D_0(e - M e) where M is the inter-layer diffusion matrix.
      // so we compute D_0(e) as D((I-M)^{-1} e)
      // note that this if at all only holds for *neutral* e (i.e. same channels)
      // other than agx-emulsion, this assumes the couplers are created relative to log exp e, not
      // an initial density (in the sense of a fixed point iteration or so)
      mat3 M = mat3(6.0, 4.0, 1.0, 4.0, 6.0, 4.0, 1.0, 4.0, 6.0);
      M[0] *= 1.0/11.0;
      M[1] *= 1.0/14.0;
      M[2] *= 1.0/11.0;
      vec3 amount = vec3(0.1, 0.2, 0.5)*params.couplers;
      M = M * mat3(amount.r, 0,0, 0, amount.g, 0, 0, 0, amount.b);
      mat3 I = mat3(1.0);
      // TODO in fact the coupler/inhibitor M*log_raw should diffuse spatially!
      // TODO write it out here, split the kernel, blur, come back (switch in main.c?)
      // as a first approximation, now we diffuse the coupler generated by our exposure within the layers
      // and adjust the radiance:
      log_raw -= M * log_raw;
      // then we need to evaluate D_0 at this location
      log_raw.r = (inverse(I-M)*log_raw.rrr).r;
      log_raw.g = (inverse(I-M)*log_raw.ggg).g;
      log_raw.b = (inverse(I-M)*log_raw.bbb).b;
      // now we went full circle and log_raw = log_raw (except for the colour that is, which is what was wanted)
    }

    vec2 tc = vec2(0.0, get_tcy(s_density_curve, film));
    vec3 tcx = clamp((gamma_factor_film*log_raw - log_exp_min)/(log_exp_max-log_exp_min), vec3(0.0), vec3(1.0));
    density_cmy.r = texture(img_filmsim, vec2(tcx.r, tc.y)).r;
    density_cmy.g = texture(img_filmsim, vec2(tcx.g, tc.y)).g;
    density_cmy.b = texture(img_filmsim, vec2(tcx.b, tc.y)).b;
    density_cmy = mix(density_cmy, vec3(0.0), isnan(density_cmy));

    // TODO do this in commit_params on cpu side, there we know the actual scale factor:
    // hack to not have grain in preview images/thumbnails:
    if(params.grain > 0 && imageSize(img_out).x > 400) density_cmy = add_grain(ipos, density_cmy);
    rgb = density_cmy;
  }

  if(params.enlarger > 0)
  {
    { // enlarger: expose film to print paper
      vec3 raw = vec3(0.0);
      // vec3 thungsten = vec3(1.0985, 1.0000, 0.3558); // 2856K
      // vec4 coeff_l = fetch_coeff(XYZ_to_rec2020(thungsten));
      // sigmoidal transmission filters for cmy:
      // vec4 coeff_c = fetch_coeff(vec3(0.153, 1.0, 0.5));
      // vec4 coeff_m = fetch_coeff(vec3(1.0, -0.1, 2.0));
      // vec4 coeff_y = fetch_coeff(vec3(1.0, 0.3, 0.0));
      // coeff_c.w = coeff_m.w = coeff_y.w = 1.0; // we want reflectance/transmittance limited to 1.0 here
      vec3 neutral = vec3(params.filter_c, params.filter_m + 0.1*params.tune_m, params.filter_y + 0.1*params.tune_y);
      // XXX TODO clamp neutral to physical range? the fitting finds negative values for some paper/film combinations..
      for(int l=0;l<=40;l++)
      {
        float lambda = 380.0 + l*10.0;
        vec2 tc = vec2(0.0, get_tcy(s_sensitivity, paper));
        tc.x = (l+0.5) / 256.0;
        vec3 log_sensitivity = texture(img_filmsim, tc).rgb;
        vec3 sensitivity = pow(vec3(10.0), log_sensitivity);
        sensitivity = mix(sensitivity, vec3(0.0), isnan(sensitivity));

        tc = vec2(0.0, get_tcy(s_dye_density, film));
        tc.x = (l+0.5) / 256.0;
        vec4 dye_density = texture(img_filmsim, tc);
        dye_density = mix(dye_density, vec4(0.0), isnan(dye_density));
        float density_spectral = dot(vec3(1), density_cmy * dye_density.xyz);
        density_spectral += dye_density.w * dye_density_min_factor_film;

        // float illuminant = 0.001*colour_blackbody(vec4(lambda), 3200.0).x;
        // float illuminant = 0.03*colour_blackbody(vec4(lambda), 2200.0).x;
        float illuminant = 0.002*colour_blackbody(vec4(lambda), 2856.0).x;
        // float illuminant = 5*sigmoid_eval(coeff_l, lambda);
#if 1 // pretty coarse manual fit to thorlabs filters:
        vec3 enlarger = 100.0*mix(
        // vec3 enlarger = mix(
            vec3(1.0),
            thorlabs_filters(lambda),
            neutral);
#else
        // lamp filters are transmittances 0..100%
        vec3 enlarger = 100.0*mix(
            vec3(1.0),
            vec3(sigmoid_eval(coeff_c, lambda), sigmoid_eval(coeff_m, lambda), sigmoid_eval(coeff_y, lambda)),
            neutral);
#endif

        float print_illuminant = enlarger.x*enlarger.y*enlarger.z * illuminant;
        float light = pow(10.0, -density_spectral) * print_illuminant;
        raw += sensitivity * light * pow(2.0, params.ev_paper); // TODO and normalise to mid gray factor
        // TODO and the same yet again for the preflash
      }
      log_raw = log(raw + 1e-10)*(1.0/log(10.0));
      rgb = raw;
    }

    { // develop print
      // interpolate log exposure to density again
      vec2 tc = vec2(0.0, get_tcy(s_density_curve, paper));
      vec3 tcx = clamp((gamma_factor_paper*log_raw - log_exp_min)/(log_exp_max-log_exp_min), vec3(0.0), vec3(1.0));
      density_cmy.r = texture(img_filmsim, vec2(tcx.r, tc.y)).r;
      density_cmy.g = texture(img_filmsim, vec2(tcx.g, tc.y)).g;
      density_cmy.b = texture(img_filmsim, vec2(tcx.b, tc.y)).b;
      rgb = density_cmy;
    }
  }

  { // scan
    // convert cmy density to spectral
    // absorption / dye density of developed film
    vec3 raw = vec3(0.0);
    vec3 d50 = vec3(0.9642, 1.0000, 0.8251); // 5002K
    vec4 coeff = fetch_coeff(d50);
    for(int l=0;l<=40;l++)
    {
      float lambda = 380 + l*10;
      vec4 dye_density = texture(img_filmsim, vec2((l+0.5) / 256.0,
            get_tcy(s_dye_density, params.enlarger > 0 ? paper : film)));
      dye_density = mix(dye_density, vec4(0.0), isnan(dye_density));
      float density_spectral = dot(vec3(1), density_cmy * dye_density.xyz);
      density_spectral += dye_density.w * dye_density_min_factor_paper;
      float scan_illuminant = 0.105*sigmoid_eval(coeff, lambda);
      float light = pow(10.0, -density_spectral) * scan_illuminant;
      vec3 cmf = cmf_1931(lambda); // 1931 2 deg std observer, approximate version
      raw += light * cmf;
    }

    rgb = XYZ_to_rec2020(raw);
  }
  imageStore(img_out, ipos, vec4(rgb, 1));
}
