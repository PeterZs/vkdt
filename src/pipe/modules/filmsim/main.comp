#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable
#include "shared.glsl"
#include "../rt/colour.glsl"
layout(local_size_x = DT_LOCAL_SIZE_X, local_size_y = DT_LOCAL_SIZE_Y, local_size_z = 1) in;
layout(std140, set = 0, binding = 1) uniform params_t
{
  int film;
  int paper;
  float gamma_film;
  float exp_paper;
  float gamma_paper;
  float filter_m;
  float filter_y;
} params;
layout(set = 1, binding = 0) uniform sampler2D img_in;
layout(set = 1, binding = 1) uniform writeonly image2D img_out;
layout(set = 1, binding = 2) uniform sampler2D img_density_curves;  // log exp to density lut
layout(set = 1, binding = 3) uniform sampler2D img_dye_density;     // spectral dye density lut
layout(set = 1, binding = 4) uniform sampler2D img_log_sensitivity; // spectral sensitivity lut
layout(set = 1, binding = 5) uniform sampler2D img_enlarger;        // spectral cmy enlarger lamp filters
layout(set = 1, binding = 6) uniform sampler2D img_density_layers;  // 3x3 data for noise synth
layout(set = 1, binding = 7) uniform sampler2D img_coeff;           // spectral upsampling for emission
#include "shared/upsample.glsl"

// TODO this needs a direct simulation method, is too slow for large n
int poisson(inout uint seed, float lambda)
{
  float u = mrand(seed);
  float b = exp(-lambda);
  int m = 60; // should be > 2x lambda or else you can see the bias
  for(int i=1;i<m;i++)
  {
    if(u < b) return i;
    u *= mrand(seed);
  }
  return m; // sorry, here.
}

int binom(inout uint seed, int n, float p)
{ // bernoulli trials
  int k = 0;
  for(int i=0;i<n;i++)
    if(mrand(seed) < p) k++;
  return k;
}

vec3 add_grain(inout uint seed, vec3 density)
{
  // statistically sample whether grains are turned or not.
  // TODO the grains need inter/sub pixel stability, use simplex noise!
  // TODO poisson something is too slow above
  // TODO do it in the three layers, use the data we have in img_density_layers
  float density_max = 3.3;
  float grain_uniformity = 1.0;
  vec3 probability_of_development = density / density_max;
  vec3 saturation = 1.0 - probability_of_development*grain_uniformity*(1.0-1e-6);
  float n_particles_per_pixel = 25.0;
  ivec3 ps = ivec3(
      poisson(seed, (n_particles_per_pixel / saturation).x),
      poisson(seed, (n_particles_per_pixel / saturation).y),
      poisson(seed, (n_particles_per_pixel / saturation).z));
  vec3 grain = vec3(
      binom(seed, ps.x, probability_of_development.x),
      binom(seed, ps.y, probability_of_development.y),
      binom(seed, ps.z, probability_of_development.z));
  grain *= saturation * density_max / n_particles_per_pixel;
  return grain;
}

void main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, imageSize(img_out)))) return;

  vec3 rgb = texelFetch(img_in, ipos, 0).rgb;

  // TODO: make parameters:
  int film  = params.film;
  int paper = 7 + params.paper;
  float dye_density_min_factor_film  = 1.0;
  float dye_density_min_factor_paper = 0.4;
  float gamma_factor_film  = params.gamma_film;
  float gamma_factor_paper = params.gamma_paper;
  float log_exp_min = -4.0;
  float log_exp_max =  4.0;

  vec3 log_raw;
  { // film exposure in camera and chemical development
    vec4 coeff = fetch_coeff(rgb);
    vec2 tc = vec2(0.0, (film + 0.5)/textureSize(img_log_sensitivity, 0).y);
    vec3 raw = vec3(0.0);
    for(int l=0;l<=40;l++)
    {
      float lambda = 380 + l*10;
      float val = sigmoid_eval(coeff, lambda);
      tc.x = (l+0.5) / 81.0;
      vec3 log_sensitivity = texture(img_log_sensitivity, tc).rgb;
      vec3 sensitivity = pow(vec3(10.0), log_sensitivity);
      // vec3 sensitivity = exp(log_sensitivity);
      sensitivity = mix(sensitivity, vec3(0.0), isnan(sensitivity));
      raw += sensitivity * val / 40.0; // XXX uh something number of bins * 10nm or something
    }
    // TODO: the following two require to split the kernel and blur the intermediates:
      // TODO gaussian blur / lens radius
      // TODO apply halation
    log_raw = log(raw+1e-10) * (1.0/log(10.0));
    // log_raw = log(raw+1e-10);
  }

  vec3 density_cmy;
  { // develop film
    uint seed = /*19937 * global.frame + */133700000 * ipos.x + ipos.y * 70007;
    vec2 tc = vec2(0.0, (film + 0.5)/textureSize(img_density_curves, 0).y);
    // TODO apply gamma factor by multiplying it to x coordinate in tc!
    tc.x = clamp((gamma_factor_film*log_raw.r - log_exp_min)/(log_exp_max-log_exp_min), 0.0, 1.0);
    density_cmy.r = texture(img_density_curves, tc).r;
    tc.x = clamp((gamma_factor_film*log_raw.g - log_exp_min)/(log_exp_max-log_exp_min), 0.0, 1.0);
    density_cmy.g = texture(img_density_curves, tc).g;
    tc.x = clamp((gamma_factor_film*log_raw.b - log_exp_min)/(log_exp_max-log_exp_min), 0.0, 1.0);
    density_cmy.b = texture(img_density_curves, tc).b;
          // TODO: this requires a kernel split/gauss blur.
          // computes new log_law and re-does the density-from-log-raw lut
        // density_cmy      = self._apply_density_correction_dir_couplers(density_cmy, log_raw, pixel_size_um)
    density_cmy = mix(density_cmy, vec3(0.0), isnan(density_cmy));
    // TODO: has some gauss blur in it, but do i want that? maybe use pixel correlated seeds instead
    density_cmy = add_grain(seed, density_cmy);
    rgb = density_cmy; // XXX
  }

  { // enlarger: expose film to print paper
    vec3 raw = vec3(0.0);
    // TODO: these come for all combinations of film and paper:
    // coefficients for cmy filters in lamp:
    // vec3 neutral = vec3(0.8239429286474425, 0.19397097820027817, 0.35);
    // values are ymc and ours is cmy
    // vec3 neutral = vec3(0.7741901967581455, 0.45280080115502647, 0.35).zyx; // kodak portra endura / kodak gold 200
    vec3 neutral = vec3(0.35, params.filter_m, params.filter_y);
    // neutral = vec3(0.005,0.008,1);
    // neutral = vec3(0,0,1);
    // neutral.y *= params.filter_m;
    // neutral.z *= params.filter_y;
    // vec4 coeff = fetch_coeff(neutral);
    for(int l=0;l<=40;l++)
    {
      float lambda = 380.0 + l*10.0;
      vec2 tc = vec2(0.0, (paper + 0.5)/textureSize(img_log_sensitivity, 0).y);
      tc.x = (l+0.5) / 81.0;
      vec3 log_sensitivity = texture(img_log_sensitivity, tc).rgb;
      // vec3 sensitivity = exp(log_sensitivity);
      vec3 sensitivity = pow(vec3(10.0), log_sensitivity);
      sensitivity = mix(sensitivity, vec3(0.0), isnan(sensitivity));

      tc = vec2(0.0, (film + 0.5)/textureSize(img_dye_density, 0).y);
      tc.x = (l+0.5) / 81.0;
      vec4 dye_density = texture(img_dye_density, tc);
      dye_density = mix(dye_density, vec4(0.0), isnan(dye_density));
      float density_spectral = dot(vec3(1), density_cmy * dye_density.xyz);
      density_spectral += dye_density.w * dye_density_min_factor_film;

      // this is from 350..800nm
      float illuminant = 0.001*colour_blackbody(vec4(lambda), 3200.0).x;
      // lamp filters are transmittances 0..100%
      vec3 enlarger = mix(
          vec3(100.0),
          texture(img_enlarger, vec2((lambda-350.0)/(800.0-350.0), 0.0)).rgb,
          neutral);

      float print_illuminant = enlarger.x*enlarger.y*enlarger.z * illuminant;
      float light = pow(10.0, -density_spectral) * print_illuminant;
      // float light = exp(-density_spectral) * print_illuminant;
      raw += sensitivity * light * pow(2.0, params.exp_paper); // TODO and normalise to mid gray factor
      // TODO and the same yet again for the preflash
    }
    // log_raw = log(raw + 1e-10);
    log_raw = log(raw + 1e-10)*(1.0/log(10.0));
    rgb = raw; // XXX
  }

  { // develop print
    // interpolate log exposure to density again
    vec2 tc = vec2(0.0, (paper + 0.5)/textureSize(img_density_curves, 0).y);
    tc.x = clamp((gamma_factor_paper*log_raw.r - log_exp_min)/(log_exp_max-log_exp_min), 0.0, 1.0);
    density_cmy.r = texture(img_density_curves, tc).r;
    tc.x = clamp((gamma_factor_paper*log_raw.g - log_exp_min)/(log_exp_max-log_exp_min), 0.0, 1.0);
    density_cmy.g = texture(img_density_curves, tc).g;
    tc.x = clamp((gamma_factor_paper*log_raw.b - log_exp_min)/(log_exp_max-log_exp_min), 0.0, 1.0);
    density_cmy.b = texture(img_density_curves, tc).b;
    // rgb = density_cmy;
  }

  { // scan
    // convert cmy density to spectral
    // absorption / dye density of developed film
    vec3 raw = vec3(0.0);
    vec3 d50 = vec3(0.9642, 1.0000, 0.8251); // 5002K
    vec4 coeff = fetch_coeff(d50);
    for(int l=0;l<=40;l++)
    {
      float lambda = 380 + l*10;
      vec2 tc = vec2(0.0, (paper + 0.5)/textureSize(img_dye_density, 0).y);
      tc.x = (l+0.5) / 81.0;
      vec4 dye_density = texture(img_dye_density, tc);
      dye_density = mix(dye_density, vec4(0.0), isnan(dye_density));
      float density_spectral = dot(vec3(1), density_cmy * dye_density.xyz);
      density_spectral += dye_density.w * dye_density_min_factor_paper;
      float scan_illuminant = 0.2*sigmoid_eval(coeff, lambda);
      float light = pow(10.0, -density_spectral) * scan_illuminant;
      // float light = exp(-density_spectral) * scan_illuminant;
      vec3 cmf = cmf_1931(lambda); // 1931 2 deg std observer, approximate version
      raw += light * cmf;
    }
    rgb = XYZ_to_rec2020(raw);
    // TODO add glare
    // TODO _apply_blur_and_unsharp
  }
  imageStore(img_out, ipos, vec4(rgb, 1));
}
