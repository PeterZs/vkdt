// markov chain path guiding:
// Lucas Alber, Johannes Hanika, and Carsten Dachsbacher.
// Real-time Markov chain path guiding for global illumination and single scattering.
// Proc. ACM Comput. Graph. Interact. Tech., 8(1), 2025. 
#version 460
void main() {}
#if 0
#extension GL_GOOGLE_include_directive              : enable
#extension GL_EXT_ray_tracing                       : enable
#extension GL_EXT_ray_query                         : enable
#extension GL_EXT_ray_tracing_position_fetch        : enable
#extension GL_EXT_shader_explicit_arithmetic_types  : enable
#extension GL_EXT_nonuniform_qualifier              : enable
#extension GL_EXT_control_flow_attributes           : enable
#extension GL_KHR_shader_subgroup_ballot            : enable
#extension GL_KHR_shader_subgroup_arithmetic        : enable

// TODO replace by vkdt versions:
#include "merian-shaders/random.glsl"
#include "merian-shaders/normal_encode.glsl"
#include "merian-shaders/grid.glsl"
#include "merian-shaders/color/colors_yuv.glsl"
#include "merian-shaders/color/colors_oklch.glsl"
#include "merian-shaders/hash.glsl"

uint rng_state;
vec2 moments;
vec3 irr;

// TODO replace:
#include "../config.h"
#include "layout.glsl"

#include "light_cache.glsl"
#include "mc.glsl"

// TODO: bring in line with ours:
#include "raytrace.glsl"

// XXX todo: maybe we want a special gbuf pass to compute directly that, so we don't have to fill it again from our gbuf structs?
// XXX we have: mat_state_t (ns, sampled colours+roughness), gbuf_t (ng, st, mat uints straight outta rt), dn buf (depth + ns)
// XXX how would we access prev pos? needs support in prepare_intersection and buf_vtx_prev. dn buf should have prev pos.
// TODO this one here is used for the ray tracing interface in merian. replace by our interface and carry on?
struct Hit {
    vec3 pos;
    vec3 prev_pos;
    vec3 wi;
    vec3 normal;
    uint enc_geonormal;

    // Material
    f16vec3 albedo;
    float16_t roughness;
};
#define pixel ivec2(gl_GlobalInvocationID)
#define resolution ivec2(imageSize(img_irradiance))
#define first_hit hits[gbuffer_index(pixel, resolution)]

// XXX new main:
// vec4 // returns rgb L + second moment of luminance
// pt_trace(
//     ivec2 ipos,      // pixel coordinate
//     uint  seed,      // random seed
//     ivec2 fbdim,     // frame buffer dimensions
//     out vec3 albedo) // return base texture on first hit as aov for denoiser
// TODO trace up to geo intersection only! volumes will be a separate pass
void main()
{
  // blue noise dither mask
  const ivec2 rp = ivec2(ipos % ivec2(textureSize(img_blue, 0)));

  camera = camera_t(0.5, vec2(1.0, fbdim.y/float(fbdim.x)), params.cam_x.xyz, mat3(1));
  camera_setup(params.cam_x.xyz, params.cam_w.xyz, params.cam_u.xyz);

  uint vidx = -1u;    // vertex index in path cache that we stored last iteration
  vec4 acc = vec4(0); // value of our estimator, accumulate this
  vec4 hrp = vec4(1); // hero wavelength p, only deviates from 1 if pdf is different per wavelength
  vec4 rand = vec4(mrand(seed), mrand(seed), mrand(seed), mrand(seed));
  vec4 contrib = vec4(1.0);
  // dithermask shows *no* difference for stratified hwl:
  uint seed2 = 19937*global.frame;
  vec4 lambda = colour_sample_lambda(dithermask(vec4(mrand(seed2)), rp), contrib, hrp);

  vec4 x;
  vec3 w, n, ng; // ray position, direction, hit normal
  vec2 st;       // texture coordinates
  uvec3 mat;
  contrib *= camera_sample_xw((ipos+filter_bh_sample(rand.yz))/fbdim, x, w);
  // contrib *= camera_sample_xw(vec2(ipos)/fbdim, x, w);
  int act = mix(1, 0, all(lessThanEqual(contrib, vec4(0.0))));

  uint flags = 0;
  float dist = 1e20;
  const float tmax = 1e12;//volume_sample_dist(x.xyz, w, mrand(seed));

  { // init first intersection vertex: read geo intersection info
    vec2 dn = texelFetch(img_dn, ipos, 0).rg;
    dist = dn.x;
    n  = geo_decode_normal(floatBitsToUint(dn.y));
    ng = geo_decode_normal(buf_mat.v[ipos.x+fbdim.x*ipos.y].ng);
    mat = uvec3(
        buf_mat.v[ipos.x+fbdim.x*ipos.y].m0,
        buf_mat.v[ipos.x+fbdim.x*ipos.y].m1,
        buf_mat.v[ipos.x+fbdim.x*ipos.y].m2);
    uint stui = buf_mat.v[ipos.x+fbdim.x*ipos.y].st;
    if(stui == -1u) n = vec3(0);
    st = unpackUnorm2x16(stui);
    if(dist < tmax) flags = 0;
    else          { flags = s_volume; dist = tmax; }
    if(dist >=1e10) flags = s_envmap;
    x.xyz = x.xyz + dist * w + 0.001*ng;
  }

#define MAX_PATH_LENGTH 3
  for(int i=0;i<MAX_PATH_LENGTH;i++)
  { // for a max number of path segments (every iteration traces one ray in addition to the eye ray)
    mat_state_t ms;
    if(act > 0)
    {
      vec3 albedo;
      ms = mat_init(mat, st, n, flags, lambda, w, albedo);
      // TODO write albedo to buffer for svgf

      if((flags & s_emit) != 0)
        acc += contrib * ms.col_emit;
    }

    act = mix(act, 0, all(lessThanEqual(contrib, vec4(0.0)))); // contribution dropped
    act = mix(act, 0, (flags & (s_emit|s_envmap)) > 0); // endpoint found
    if(subgroupAdd(act) <= 0) break; // keep subgroup in sync

    if(act > 0)
    { // SAMPLE NEXT OUTGOING DIRECTION
      vec3 wo;
      float wodotn;
      float wo_p = 0;

#if MCPG_REFERENCE_MODE==1
      rand = vec4(mrand(seed), mrand(seed), mrand(seed), mrand(seed));
      w = mat_sample(ms, flags, w, n, lambda, rand.xyz, contrib);
      if(dot(ng, w) <= 0) act = 0;
#else
      MCState mc_state;
      uint mc_buffer_index;

      float score_sum = 0;
      {
        float scores[MC_SAMPLES];
        vec4 vmfs[MC_SAMPLES];
        {
          [[unroll]] for (int i = 0; i < MC_SAMPLES; i++)
          {
            const bool adaptive_grid = XorShift32(rng_state) < MC_SAMPLES_ADAPTIVE_PROB;

            uint buffer_index, hash;
            if (adaptive_grid)
              mc_adaptive_buffer_index(s == 0 ? current_hit.prev_pos : current_hit.pos, current_hit.normal, buffer_index, hash);
            else
              mc_static_buffer_index(s == 0 ? current_hit.prev_pos : current_hit.pos, buffer_index, hash);

            MCState state = mc_states[buffer_index];

            if (adaptive_grid)
              mc_adaptive_finalize_load(state, hash);
            else
              mc_static_finalize_load(state, hash, current_hit.pos, current_hit.normal);

            scores[i] = state.sum_w;
            score_sum += state.sum_w;
            vmfs[i] = mc_state_get_vmf(state, current_hit.pos);
            if (XorShift32(rng_state) < scores[i] / score_sum)
            {
              // we use here that comparison with NaN is false, that happens if candidate_score == 0 and sum == 0; 
              mc_state = state;
              mc_buffer_index = buffer_index;
              wo = vmf_sample(vmfs[i].xyz, vmfs[i].w, XorShift32Vec2(rng_state));
            }
          }
        }

        if (score_sum == 0 || XorShift32(rng_state) < SURF_BSDF_P)
        {
          // BSDF Sampling
          wo = bsdf_ggx_diffuse_mix_sample(current_hit.wi, current_hit.normal, bsdf_ggx_roughness_to_alpha(current_hit.roughness), XorShift32Vec3(rng_state));
          mc_state = mc_state_new();
        } // else {VMF Sampling // wo = set above }
      wodotn = dot(wo, current_hit.normal);

      // ray is below geometric surface
      if (wodotn <= 1e-3 || dot(wo, geo_decode_normal(current_hit.enc_geonormal)) <= 1e-3)
        break;

      // Multiple importance sampling
      [[unroll]] for (int i = 0; i < MC_SAMPLES; i++)
      {
        // score_sum > 0 ? results in black artifacts
        wo_p += (scores[i] > 0 ? scores[i] * (vmf_pdf(wo, vmfs[i].xyz, vmfs[i].w)) / score_sum : 0);
      }
      wo_p = (score_sum > 0 ? SURF_BSDF_P : 1.0) *
        // XXX our material pdf here
        bsdf_ggx_diffuse_mix_pdf(current_hit.wi, wo, current_hit.normal, bsdf_ggx_roughness_to_alpha(current_hit.roughness)) + (1 - SURF_BSDF_P) * wo_p;

      }
#endif
    }

    dist = tmax; // trace ray
    if(cast_ray(w, x.xyz, dist, n, ng, st, mat)) flags = 0;
    else if(dist < tmax) flags = s_volume;
    if(dist >= 1e10)     flags = s_envmap;

    // TODO
    // Full GI (infinite diffuse bounces)
    const f16vec3 lc_incident = any(greaterThan(incident, f16vec3(0))) || (USE_LIGHT_CACHE_TAIL == 0 && MAX_PATH_LENGTH == 2) ? incident : throughput * light_cache_get(next_hit.pos, next_hit.normal).rgb;

    // EVAL BSDF
    // without albedo (added below to skip first albedo)
    // TODO use our mat model
      const float microfacet_bsdf = bsdf_ggx_diffuse_mix_times_wodotn(current_hit.wi, wo, current_hit.normal, bsdf_ggx_roughness_to_alpha(current_hit.roughness), 0.02);

      current_throughput *= microfacet_bsdf;
      f = current_throughput * (i < MAX_PATH_LENGTH - 1 ? incident : lc_incident);
      p *= wo_p;
      current_throughput *= throughput;

      { // UPDATE MARKOV CHAIN and LIGHT_CACHE
        // multiply albedo?
        const float mc_f = luminance_rec2020(lc_incident * microfacet_bsdf / wo_p);
        if (!isinf(mc_f) && !isnan(mc_f))
        {
          light_cache_update(current_hit.pos, current_hit.normal, lc_incident * bsdf_diffuse_eval(current_hit.albedo) * wodotn / max(wo_p, 10));

          if (XorShift32(rng_state) * score_sum < mc_f * MC_SAMPLES)
          {
            // == XorShift32(rng_state) < mc_f / (score_sum / MC_SAMPLES)
            mc_state_add_sample(mc_state, current_hit.pos, mc_f, next_hit.pos, (next_hit.pos - next_hit.prev_pos) / TIME_DIFF);
            mc_static_save(mc_state, current_hit.pos, current_hit.normal);
            mc_adaptive_save(mc_state, current_hit.pos, current_hit.normal);
          }
          else if (MC_FAST_RECOVERY == 1 && mc_light_missing(mc_state, mc_f, wo, current_hit.pos))
          {
            // fix slow recovery after light source disappears
            mc_states[mc_buffer_index].sum_w = 0.;
          }
        }
      }

      // XXX i think we want to be doing this above when evaluating the material
        // current_throughput *= next_hit.albedo;
        // current_hit = next_hit;

    if(subgroupAdd(act) <= 0) break; // keep subgroup in sync
  }
  vec4 acc_rgb;
  acc_rgb.rgb = colour_to_rgb(acc, lambda, hrp);
  uint pidx = ipos.x + fbdim.x * ipos.y;


  // TODO write irradiance and moment buffers

  return acc_rgb;
}

void main()
{
  rng_state = pcg4d16(uvec4(pixel, params.frame, SEED));
  moments = vec2(0);
  irr = vec3(0);

  if (any(greaterThanEqual(first_hit.albedo, f16vec3(1e-7)))) for (int s = 0; s < SURFACE_SPP; s++)
  {
    Hit current_hit = first_hit;

    // Camera throughput encoded in albedo
    vec3 current_throughput = vec3(1);
    vec3 f = vec3(0);
    float p = 1.0;

    for (int segment = 1; segment < MAX_PATH_LENGTH; segment++)
    {
      vec3 wo;
      float wodotn;
      float wo_p = 0;

#if MERIAN_QUAKE_REFERENCE_MODE == 1
      wo = bsdf_ggx_diffuse_mix_sample(current_hit.wi, current_hit.normal, bsdf_ggx_roughness_to_alpha(current_hit.roughness), XorShift32Vec3(rng_state));
      wodotn = dot(wo, current_hit.normal);
      if (wodotn <= 1e-3 || dot(wo, geo_decode_normal(current_hit.enc_geonormal)) <= 1e-3)
        break;
      wo_p = bsdf_ggx_diffuse_mix_pdf(current_hit.wi, wo, current_hit.normal, bsdf_ggx_roughness_to_alpha(current_hit.roughness));
#else

      MCState mc_state;
      uint mc_buffer_index;

      // SAMPLE NEXT OUTGOING DIRECTION
      float score_sum = 0;
      {
        float scores[MC_SAMPLES];
        vec4 vmfs[MC_SAMPLES];
        {
          [[unroll]] for (int i = 0; i < MC_SAMPLES; i++)
          {
            const bool adaptive_grid = XorShift32(rng_state) < MC_SAMPLES_ADAPTIVE_PROB;

            uint buffer_index, hash;
            if (adaptive_grid)
              mc_adaptive_buffer_index(s == 0 ? current_hit.prev_pos : current_hit.pos, current_hit.normal, buffer_index, hash);
            else
              mc_static_buffer_index(s == 0 ? current_hit.prev_pos : current_hit.pos, buffer_index, hash);

            MCState state = mc_states[buffer_index];

            if (adaptive_grid)
              mc_adaptive_finalize_load(state, hash);
            else
              mc_static_finalize_load(state, hash, current_hit.pos, current_hit.normal);

            scores[i] = state.sum_w;
            score_sum += state.sum_w;
            vmfs[i] = mc_state_get_vmf(state, current_hit.pos);
            if (XorShift32(rng_state) < scores[i] / score_sum)
            {
              // we use here that comparison with NaN is false, that happens if candidate_score == 0 and sum == 0; 
              mc_state = state;
              mc_buffer_index = buffer_index;
              wo = vmf_sample(vmfs[i].xyz, vmfs[i].w, XorShift32Vec2(rng_state));
            }
          }
        }

        if (score_sum == 0 || XorShift32(rng_state) < SURF_BSDF_P)
        {
          // BSDF Sampling
          wo = bsdf_ggx_diffuse_mix_sample(current_hit.wi, current_hit.normal, bsdf_ggx_roughness_to_alpha(current_hit.roughness), XorShift32Vec3(rng_state));
          mc_state = mc_state_new();
        } // else {VMF Sampling // wo = set above }
      wodotn = dot(wo, current_hit.normal);

      // ray is below geometric surface
      if (wodotn <= 1e-3 || dot(wo, geo_decode_normal(current_hit.enc_geonormal)) <= 1e-3)
        break;

      // Multiple importance sampling
      [[unroll]] for (int i = 0; i < MC_SAMPLES; i++)
      {
        // score_sum > 0 ? results in black artifacts
        wo_p += (scores[i] > 0 ? scores[i] * (vmf_pdf(wo, vmfs[i].xyz, vmfs[i].w)) / score_sum : 0);
      }
      wo_p = (score_sum > 0 ? SURF_BSDF_P : 1.0) * bsdf_ggx_diffuse_mix_pdf(current_hit.wi, wo, current_hit.normal, bsdf_ggx_roughness_to_alpha(current_hit.roughness)) + (1 - SURF_BSDF_P) * wo_p;

      }
#endif

      // TRACE RAY TO NEXT SURFACE
      Hit next_hit;
      next_hit.wi = wo;
      // Pull back the ray such that it cannot excape through corners (and to prevent self collision)
      next_hit.pos = current_hit.pos - current_hit.wi * 1e-3;
      f16vec3 incident = f16vec3(0); // contains throughput already
      f16vec3 throughput = f16vec3(1);
      trace_ray(throughput, incident, next_hit);
      // Full GI (infinite diffuse bounces)
      const f16vec3 lc_incident = any(greaterThan(incident, f16vec3(0))) || (USE_LIGHT_CACHE_TAIL == 0 && MAX_PATH_LENGTH == 2) ? incident : throughput * light_cache_get(next_hit.pos, next_hit.normal).rgb;

      // EVALUATE BSDF
      // without albedo (added below to skip first albedo)
      const float microfacet_bsdf = bsdf_ggx_diffuse_mix_times_wodotn(current_hit.wi, wo, current_hit.normal, bsdf_ggx_roughness_to_alpha(current_hit.roughness), 0.02);

      current_throughput *= microfacet_bsdf;
#if USE_LIGHT_CACHE_TAIL == 1 
      f = current_throughput * (segment < MAX_PATH_LENGTH - 1 ? incident : lc_incident);
#else
      f = current_throughput * incident;
#endif
      p *= wo_p;
      current_throughput *= throughput;

      // UPDATE MARKOV CHAIN and LIGHT_CACHE
#if MERIAN_QUAKE_REFERENCE_MODE != 1
      {
        // multiply albedo?
        const float mc_f = yuv_luminance(lc_incident * microfacet_bsdf / wo_p);
        if (!isinf(mc_f) && !isnan(mc_f))
        {
          light_cache_update(current_hit.pos, current_hit.normal, lc_incident * bsdf_diffuse_eval(current_hit.albedo) * wodotn / max(wo_p, 10));

          if (XorShift32(rng_state) * score_sum < mc_f * MC_SAMPLES)
          {
            // == XorShift32(rng_state) < mc_f / (score_sum / MC_SAMPLES)
            mc_state_add_sample(mc_state, current_hit.pos, mc_f, next_hit.pos, (next_hit.pos - next_hit.prev_pos) / TIME_DIFF);
            mc_static_save(mc_state, current_hit.pos, current_hit.normal);
            mc_adaptive_save(mc_state, current_hit.pos, current_hit.normal);
          }
          else if (MC_FAST_RECOVERY == 1 && mc_light_missing(mc_state, mc_f, wo, current_hit.pos))
          {
            // fix slow recovery after light source disappears
            mc_states[mc_buffer_index].sum_w = 0.;
          }
        }
      }
#endif
      // PREPARE NEXT ITERATION
      {
        current_throughput *= next_hit.albedo;
        current_hit = next_hit;

        // we stop if we won't transport any more light or if we found emissive material
        if (all(lessThan(current_throughput, vec3(1e-7))) || any(greaterThan(f, vec3(1e-7))))
          break;
      }
    }

    const vec3 contrib = f / p;
    if(!any(isinf(contrib)) && !any(isnan(contrib)))
    {
      irr += contrib;
      const float l = yuv_luminance(contrib);
      moments += vec2(l, l * l);
    }
  }

  if (any(greaterThanEqual(pixel, resolution)))
    return;

  if (SURFACE_SPP > 0)
  {
    irr /= SURFACE_SPP;
    moments /= SURFACE_SPP;
  }

  imageStore(img_irradiance, pixel, vec4(irr, SURFACE_SPP));
  imageStore(img_moments, pixel, vec4(moments, 0, 0));
}
#endif
