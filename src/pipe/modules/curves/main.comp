#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable
#include "shared.glsl"
layout(local_size_x = DT_LOCAL_SIZE_X, local_size_y = DT_LOCAL_SIZE_Y, local_size_z = 1) in;
layout(std140, set = 0, binding = 1) uniform params_t
{
  vec4 abcdr[8];
  vec4 abcdg[8];
  vec4 abcdb[8];
  vec4 xr0, xr1;
  vec4 xg0, xg1;
  vec4 xb0, xb1;
  vec4 yr0, yr1;
  vec4 yg0, yg1;
  vec4 yb0, yb1;
  int  cntr, cntg, cntb;
  int  sel;
  int  chan;
  float ddr0, ddrn;
  float ddg0, ddgn;
  float ddb0, ddbn;
} params;
layout(set = 1, binding = 0) uniform sampler2D img_in;
layout(set = 1, binding = 1) uniform writeonly image2D img_out;
layout(set = 1, binding = 2) uniform writeonly image2D img_dspy;

// TODO
// * histogram in bg
// * other modes? oklab hue vs hue vs all combinations
vec4 abcd(int c, int i)
{
  if(c == 0) return params.abcdr[i];
  if(c == 1) return params.abcdg[i];
  if(c == 2) return params.abcdb[i];
}

float curve_x(int c, int i)
{
  if(c == 0)
  {
    if(i == 0) return params.xr0.x;
    if(i == 1) return params.xr0.y;
    if(i == 2) return params.xr0.z;
    if(i == 3) return params.xr0.w;
    if(i == 4) return params.xr1.x;
    if(i == 5) return params.xr1.y;
    if(i == 6) return params.xr1.z;
    if(i == 7) return params.xr1.w;
  }
  else if(c == 1)
  {
    if(i == 0) return params.xg0.x;
    if(i == 1) return params.xg0.y;
    if(i == 2) return params.xg0.z;
    if(i == 3) return params.xg0.w;
    if(i == 4) return params.xg1.x;
    if(i == 5) return params.xg1.y;
    if(i == 6) return params.xg1.z;
    if(i == 7) return params.xg1.w;
  }
  else if(c == 2)
  {
    if(i == 0) return params.xb0.x;
    if(i == 1) return params.xb0.y;
    if(i == 2) return params.xb0.z;
    if(i == 3) return params.xb0.w;
    if(i == 4) return params.xb1.x;
    if(i == 5) return params.xb1.y;
    if(i == 6) return params.xb1.z;
    if(i == 7) return params.xb1.w;
  }
}

float curve_y(int c, int i)
{
  if(c == 0)
  {
    if(i == 0) return params.yr0.x;
    if(i == 1) return params.yr0.y;
    if(i == 2) return params.yr0.z;
    if(i == 3) return params.yr0.w;
    if(i == 4) return params.yr1.x;
    if(i == 5) return params.yr1.y;
    if(i == 6) return params.yr1.z;
    if(i == 7) return params.yr1.w;
  }
  else if(c == 1)
  {
    if(i == 0) return params.yg0.x;
    if(i == 1) return params.yg0.y;
    if(i == 2) return params.yg0.z;
    if(i == 3) return params.yg0.w;
    if(i == 4) return params.yg1.x;
    if(i == 5) return params.yg1.y;
    if(i == 6) return params.yg1.z;
    if(i == 7) return params.yg1.w;
  }
  else if(c == 2)
  {
    if(i == 0) return params.yb0.x;
    if(i == 1) return params.yb0.y;
    if(i == 2) return params.yb0.z;
    if(i == 3) return params.yb0.w;
    if(i == 4) return params.yb1.x;
    if(i == 5) return params.yb1.y;
    if(i == 6) return params.yb1.z;
    if(i == 7) return params.yb1.w;
  }
}

float curve_eval(int c, float x, out float ddx)
{ // cubic spline
  float x0 = curve_x(c, 0);
  float y0 = curve_y(c, 0);
  float x1, y1;
  const int cnt = c == 0 ? params.cntr : c == 1 ? params.cntg : params.cntb;
  ddx = c==0?params.ddr0:c==1?params.ddg0:params.ddb0;
  if(x <= x0) return y0 + (x-x0)*ddx;
  for(int i=0;i<cnt-1;i++)
  {
    x1 = curve_x(c, i+1);
    y1 = curve_y(c, i+1);
    if(x <= x1)
    {
      x -= x0;
      vec4 d = vec4(0, 1, 2*x, 3*x*x);
      vec4 p = vec4(1, x, x*x, x*x*x);
      vec4 cf = abcd(c, i);
      ddx = dot(cf, d);
      return dot(cf, p);
    }
    x0 = x1;
    y0 = y1;
  }
  ddx = c==0?params.ddrn:c==1?params.ddgn:params.ddbn;
  return y1 + (x-x1)*ddx;
}

#if 0 // linear
float curve_eval(float x, out float ddx)
{
  float x0 = curve_x(0);
  float y0 = curve_y(0);
  float x1, y1;
  if(x <= x0) return y0;
  for(int i=1;i<params.cnt;i++)
  {
    x1 = curve_x(i);
    y1 = curve_y(i);
    if(x <= x1)
    {
      ddx = (y1-y0)/(x1-x0);
      return mix(y0, y1, (x-x0)/(x1-x0));
    }
    x0 = x1;
    y0 = y1;
  }
  return y1;
}
#endif

void main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, imageSize(img_out)))) return;
  vec3 rgb = texelFetch(img_in, ipos, 0).rgb;
  imageStore(img_out, ipos, vec4(rgb, 1));

  if(any(greaterThanEqual(ipos, imageSize(img_dspy)))) return;
  vec4 col_crv = vec4(0, 0, 0, 1);
  for(int c=0;c<3;c++)
  { // draw all three curves
    const int cnt = c == 0 ? params.cntr : c == 1 ? params.cntg : params.cntb;
    vec3 col = vec3(c==0?0.9:0.1,c==1?0.9:0.1,c==2?0.9:0.1);
    float of0 = 0;//0.1; // extend range outside [0,1]?
    float off = of0 * imageSize(img_dspy).x;
    float x = ipos.x/float(imageSize(img_dspy).x - off);
    float ddx;
    float y = curve_eval(c, x, ddx);
    const float w = c == params.chan ? 5.0 : 1.0; // stroke width
    float t = w * sqrt(1.0 + ddx*ddx); // line thinckness along const y
    float d = abs((1.0+of0-y) * (1.0-of0) * imageSize(img_dspy).y - ipos.y);
    col_crv = max(col_crv, vec4(col, 0.2) * vec4(vec3(smoothstep(t, 0.0, d)), 1));
    if(c == params.chan)
    { // draw (selected) points
      off = of0 * imageSize(img_dspy).y;
      y = 1.0-ipos.y/float(imageSize(img_dspy).y - off);
      for(int i=0;i<cnt;i++)
      {
        vec2 dist = vec2(x,y)-vec2(curve_x(c, i), curve_y(c, i));
        d = dot(dist,dist);
        float rad = params.sel == i ? 0.03 : 0.02;
        if(d < rad*rad)
          col_crv = max(col_crv, vec4(col, 0.2) * vec4(vec3(smoothstep(rad, 0.0, d)), 1));
      }
    }
  }
  imageStore(img_dspy, ipos, col_crv);
}
